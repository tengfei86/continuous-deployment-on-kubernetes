// Comments: Following is the json read post request body. These are in form of key value pairs.
// All keys are case sensitive and fixed.
// Values for keys has specific format
// language is required and it is case sensitive and only en value is supported for now
// timezone is required and it is case sensitive. Timezone value only supports specific format GMT+xx:xx, GMT-xx:xx
// Values for keys boName and boAttrName are case insensitive
// Values for key boName are pre-defined in metadata table BUSINESS_OBJECT
// Values for key boAttrName are also pre-defined in metadata table BUSINESS_OBJECT_ATTR
{
  "boName": "AREA TYPE",
  // required
  "language": "en",
  // required
  "timezone": "GMT+05:00",
  // required
  "joinAlias": "area_1",
  // required in case of using simple join or dynamic join feature   
  // unit conversion unitPolicy has three options: 
  "unitPolicy":"custom",
  //1.system: get the source units from business_object_attr table unit field, there is no unit conversion. 
  //2.user: 
  //  2.1 get the source units from business_object_attr table unit field,
  //  2.2 get the target units 
  //	  2.2.1 from user_unit_settings  
  //      2.2.2 if 2.2.2 can't get units , then from unit_template_details associates user_current_unit_templates
  //	  2.2.3 if 2.2.3 can't get units , then from unit_template_details associates unit_template_templates where is_default is true 
  // 	  2.2.4 if 2.2.3 can't get units , target units return null ,there is no unit conversion .
  //3.custom: 
  //  3.1 get the source units come from business_object_attribute table unit field . 
  //  3.2 get the target units come from dspdmUnits node
  //when unitPolicy is custom , the dspdmUnits are the target units by fields.
  "dspdmUnits":[ 
    { 
      "boAttrName":"{bo_attr_name}", 
      //corresponds to a field in itself and dynamicJoins selectLists that contains unit 
      "targetUnit":"{unit}" 
      //target unit
    } 
  ],    
  "selectList": [
    // optional and default is * means all the columns defined in metadata will be selected
    "ENTITY",
    "BO_NAME",
    "ENTITY_DISPLAY_NAME"
  ],
  "aggregateSelectList": [
    {
      // optional and default is the selectList or * means all the columns defined in metadata will be selected
      // you can use aggregate function MIN, MAX, SUM, AVG and Count to read the data
      // Note : If you use aggregateSelectList and not using selectList then only aggregateSelectList columns
      // will be selected and no select * will be applied anywhere.
      // Note : If you use aggregateSelectList along with the selectList then all the columns of the selectList
      // will automatically be added to the SQL Group By clause by the service and result will be a group by result on on aggregate columns
      "boAttrName": "WELL_ID",
      // mandatory
      "aggregateFunction": "MAX",
      // mandatory
      "alias": "MAX_WELL_ID"
      // mandatory and will be used to get back the value from the response
    },
    {
      "boAttrName": "WELL_ID",
      "aggregateFunction": "MIN",
      "alias": "MIN_WELL_ID"
    }
  ],
  "criteriaFilters": [
    // optional and if multiple criteria are provided they will be concatenated with AND SQL operator
    // operator key and value both are case sensitive
    // SUPPORTED OPERATORS are as follows
    // EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, GREATER_OR_EQUALS, LESS_OR_EQUALS, BETWEEN, NOT_BETWEEN, IN, NOT_IN, LIKE, NOT_LIKE, ILIKE, NOT_ILIKE, JSONB_FIND_EXACT, JSONB_FIND_LIKE, JSONB_DOT, JSONB_DOT_FOR_TEXT
    {
      "boAttrName": "IS_REFERENCE_IND",
      "operator": "EQUALS",
      "values": [
        "Y"
      ]
    },
    {
      "boAttrName": "UWI",
      "operator": "LIKE",
      "values": [
        "UWI-12345"
      ]
    },
    {
      "boAttrName": "WELL_ID",
      "operator": "IN",
      "values": [
        1,
        2,
        3,
        4,
        5
      ]
    },
    {
      "boAttrName": "WELL ID",
      "operator": "BETWEEN",
      "values": [
        21,
        29
      ]
    }
  ],
  "havingFilters": [
    // optional and if multiple having criteria are provided they will be concatenated  with AND SQL operator
    // Having filters are apllied to the grouped data after grouping on the data has been done
    // whereas normal criteria filters work before grouping and they work on the raw data and become part of where clause
    // Having filters should only be used to do some filtering on the basis of some aggregate functions.
    // If you do not have to use any aggregate function in having filter then please use criteria filter
    // operator key and value both are case sensitive
    // SUPPORTED aggregateFunction are MIN, MAX, SUM, AVG, COUNT
    // SUPPORTED OPERATORS are as follows
    // EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, GREATER_OR_EQUALS, LESS_OR_EQUALS, BETWEEN, NOT_BETWEEN, IN, NOT_IN, LIKE, NOT_LIKE, ILIKE, NOT_ILIKE
    {
      "aggregateColumn": {
        "boAttrName": "WELL_ID",
        // mandatory
        "aggregateFunction": "MAX"
        // mandatory
      },
      "operator": "LESS_THAN",
      // mandatory
      "values": [
        // mandatory
        "2000"
      ]
    },
    {
      "aggregateColumn": {
        "boAttrName": "WELL_ID",
        "aggregateFunction": "MIN"
      },
      "operator": "GREATER_THAN",
      "values": [
        "1000"
      ]
    }
  ],
  "orderBy": [
    // optional
    {
      "boAttrName": "UWI",
      "order": "ASC"
      // optional and default to ASC
    },
    {
      "boAttrName": "SPUD DATE",
      "order": "DESC"
      // optional and default to ASC
    }
  ],
  "pagination": {
    "recordsPerPage": 30,
    // optional and defualt to 500
    "pages": [
      1,
      2
    ]
    // optional and defualt to 1
  },
  "dynamicJoins": [
    {
      "selectList": [
        "UWI"
      ],
      "aggregateSelectList": [
        {
          "boAttrName": "max_volume_date",
          "aggregateFunction": "MAX",
          "alias": "max_volume_date"
        }
      ],
      "joinType": "INNER",
      "joinAlias": "b",
      "dynamicTables": [
        {
          "boName": "well vol daily",
          "selectList": [
            "UWI"
          ],
          "aggregateSelectList": [
            {
              "boAttrName": "volume_date",
              "aggregateFunction": "MAX",
              "alias": "max_volume_date"
            }
          ]
        }
      ],
      "joiningConditions": [
        {
          "leftSide": {
            "joinAlias": "a",
            "boAttrName": "UWI"
          },
          "operator": "EQUALS",
          "rightSide": {
            "joinAlias": "b",
            "boAttrName": "UWI"
          }
        },
        {
          "leftSide": {
            "joinAlias": "a",
            "boAttrName": "volume_date"
          },
          "operator": "EQUALS",
          "rightSide": {
            "joinAlias": "b",
            "boAttrName": "max_volume_date"
          }
        }
      ],
      "criteriaFilters": [
        {
          "boAttrName": "UWI",
          "operator": "LIKE",
          "values": [
            "PH"
          ]
        }
      ],
      "havingFilters": [
        {
          "aggregateColumn": {
            "boAttrName": "max_volume_date",
            "aggregateFunction": "MAX"
          },
          "operator": "GREATER_THAN",
          "values": [
            "2019-11-24 00:00:00"
          ]
        }
      ]
    }
  ],
  "prependAlias": false
  // optional and can be used to identify same column names from different business objects.
}